Features
Pipecat Flows
Learn how to create structured conversations using Pipecat’s flow system

Pipecat Flows provides a framework for building structured conversations in your AI applications. It enables you to create both predefined conversation paths and dynamically generated flows while handling the complexities of state management and LLM interactions.

The framework consists of:

A Python module for building conversation flows with Pipecat
A visual editor for designing and exporting flow configurations
​
Key Concepts
Nodes: Represent conversation states with specific messages and available functions
Messages: Set the role and tasks for each node
Functions: Define actions and transitions (Node functions for operations, Edge functions for transitions)
Actions: Execute operations during state transitions (pre/post actions)
State Management: Handle conversation state and data persistence
​
Example Flows
Movie Explorer (Static)
A static flow demonstrating movie exploration using OpenAI. Shows real API integration with TMDB, structured data collection, and state management.

Insurance Policy (Dynamic)
A dynamic flow using Google Gemini that adapts policy recommendations based on user responses. Demonstrates runtime node creation and conditional paths.

These examples are fully functional and can be run locally. Make sure you have the required dependencies installed and API keys configured.

​
When to Use Static vs Dynamic Flows
Static Flows are ideal when:

Conversation structure is known upfront
Paths follow predefined patterns
Flow can be fully configured in advance
Example: Customer service scripts, intake forms
Dynamic Flows are better when:

Paths depend on external data
Flow structure needs runtime modification
Complex decision trees are involved
Example: Personalized recommendations, adaptive workflows
​
Installation
If you’re already using Pipecat:


Copy
pip install pipecat-ai-flows
If you’re starting fresh:


Copy
# Basic installation
pip install pipecat-ai-flows

# Install Pipecat with specific LLM provider options:
pip install "pipecat-ai[daily,openai,deepgram]"     # For OpenAI
pip install "pipecat-ai[daily,anthropic,deepgram]"  # For Anthropic
pip install "pipecat-ai[daily,google,deepgram]"     # For Google
💡 Want to design your flows visually? Try the online Flow Editor

​
Core Concepts
​
Designing Conversation Flows
Functions in Pipecat Flows serve two key purposes:

interfacing with external systems and APIs through LLM function calls
advancing the conversation to the next node
​
Function Handlers
When you need to collect data, validate input, or retrieve information, add a handler to your function. These handlers are async functions that execute when the LLM calls the function, allowing you to interact with databases, APIs, or other external services:

Function handlers can use one of two signature patterns:


Modern (with FlowManager)

Legacy (args only)

Copy
async def check_availability(args: FlowArgs, flow_manager: FlowManager) -> FlowResult:
    """Check restaurant availability, with access to flow manager.

    This signature gives you access to conversation state, transport methods,
    and other flow resources.
    """
    # Get requested date from args
    date = args["date"]
    time = args["time"]

    # Get party size from either args or state
    party_size = args.get("party_size", flow_manager.state.get("party_size"))

    # Use flow_manager for immediate user feedback
    await flow_manager.task.queue_frame(TTSSpeakFrame("Checking our reservation system..."))

    # Store data in flow state for later use
    flow_manager.state["requested_date"] = date

    # Interface with reservation system
    available = await reservation_system.check_availability(date, time, party_size)

    return {"status": "success", "available": available}
The framework automatically detects which signature you’re using and calls your handler appropriately.

​
Transitioning Between Nodes
To advance the conversation, Pipecat Flows offers two approaches based on your flow type:

For static flows, use the transition_to property to specify the next node:


Copy
{
    "type": "function",
    "function": {
        "name": "confirm_reservation",
        "handler": save_reservation,  # Process the reservation
        "parameters": {...},
        "transition_to": "send_confirmation"  # Move to confirmation node
    }
}
For dynamic flows, use a transition callback to determine the next node at runtime:


Copy
{
    "type": "function",
    "function": {
        "name": "confirm_reservation",
        "handler": save_reservation,  # Process the reservation
        "parameters": {...},
        "transition_callback": send_confirmation  # Call the corresponding handler to set_node()
    }
}
​
Transition Callbacks (Dynamic Flows)
Transition callbacks receive both the original function arguments and the typed result:


Copy
async def handle_confirmation(
    args: Dict,           # Original function arguments
    result: FlowResult,   # Typed result from handler
    flow_manager: FlowManager
):
    """Handle transition based on function result."""
    if result["success"]:
        await flow_manager.set_node("send_confirmation", create_confirmation_node())
    else:
        await flow_manager.set_node(
            "retry_reservation",
            create_retry_node(result.error_message)
        )
For backwards compatibility, callbacks can also use the two-argument signature:


Copy
async def handle_confirmation(args: Dict, flow_manager: FlowManager):
    """Legacy transition handler."""
    await flow_manager.set_node("next", create_next_node())
You can combine both approaches: use handlers to process data and transitions to advance the conversation, creating flows that are both functional and conversational.

​
Node Structure
Each node in your flow represents a conversation state and consists of three main components:

​
Messages
Nodes use two types of messages to control the conversation:

Role Messages: Define the bot’s personality or role (optional)

Copy
"role_messages": [
    {
        "role": "system",
        "content": "You are a friendly pizza ordering assistant. Keep responses casual and upbeat."
    }
]
Task Messages: Define what the bot should do in the current node

Copy
"task_messages": [
    {
        "role": "system",
        "content": "Ask the customer which pizza size they'd like: small, medium, or large."
    }
]
Role messages are typically defined in your initial node and inherited by subsequent nodes, while task messages are specific to each node’s purpose.

​
Functions
Functions in Pipecat Flows can:

Process data (using handler)
Create transitions (using transition_to for static or transition_callback for dynamic flows)
Do both simultaneously
This leads to two conceptual types of functions:

Node functions, which execute a handler within a state
Edge function, which create transitions between nodes and optionally executes a handler
Function type is defined implicitly based on the existence (or absence) of the transition properties

​
Function Schemas
Pipecat Flows supports two ways to define functions:

Provider-specific dictionary format

Copy
# Dictionary format
{
    "type": "function",
    "function": {
        "name": "select_size",
        "handler": select_size,
        "description": "Select pizza size",
        "parameters": {
            "type": "object",
            "properties": {
                "size": {"type": "string", "enum": ["small", "medium", "large"]}
            }
        },
        "transition_to": "toppings"
    }
}
FlowsFunctionSchema

Copy
# Using FlowsFunctionSchema
from pipecat_flows import FlowsFunctionSchema

size_function = FlowsFunctionSchema(
    name="select_size",
    description="Select pizza size",
    properties={
        "size": {"type": "string", "enum": ["small", "medium", "large"]}
    },
    required=["size"],
    handler=select_size,
    transition_to="toppings"
)

# Use in node configuration
node_config = {
    "task_messages": [...],
    "functions": [size_function]
}
The FlowsFunctionSchema approach provides:

Consistent structure across LLM providers
Simplified parameter definition
Cleaner, more readable code
Both approaches are fully supported. FlowsFunctionSchema is recommended for new projects as it provides better type checking and a provider-independent format.

​
Node Functions
Functions that process data within a state. They typically:

Have a handler to interface with external systems or APIs
Trigger an immediate LLM completion with the result

Copy
from pipecat_flows import FlowArgs, FlowResult

async def select_size(args: FlowArgs) -> FlowResult:
    """Process pizza size selection."""
    size = args["size"]
    return {
        "status": "success",
        "size": size
    }

# Node function configuration
{
    "type": "function",
    "function": {
        "name": "select_size",
        "handler": select_size,           # Required: Processes the selection
        "description": "Select pizza size",
        "parameters": {
            "type": "object",
            "properties": {
                "size": {"type": "string", "enum": ["small", "medium", "large"]}
            }
        },
    }
}
​
Edge Functions
Functions that create transitions between nodes. When called, they:

Execute their handler (if one is provided)
Add function results to context
Must have transition_to (static flow) or transition_callback (dynamic flow) to specify the next state
Trigger LLM completion after both the function result and new node’s messages are in context

Copy
# Edge function configuration
{
    "type": "function",
    "function": {
        "name": "next_step",
        "description": "Move to next state",
        "parameters": {"type": "object", "properties": {}},
        "handler": select_size,        # Optional: Process data during transition
        "transition_to": "target_node" # Required: Specify next state
    }
}
A function’s behavior is determined by its properties:

handler only: Process data, stay in current state
transition_to (static flow) or transition_callback (dynamic flow) only: Pure transition to next state
Both: Process data, then transition
​
Actions
Actions are operations that execute during state transitions, with two distinct timing options:

Pre-actions: execute before the LLM completion
Post-actions: execute after the LLM completion
​
Pre-Actions
Execute before LLM inference. Useful for:

Providing immediate feedback while waiting for LLM responses
Bridging gaps during longer function calls
Setting up state or context

Copy
"pre_actions": [
    {
        "type": "tts_say",
        "text": "Hold on a moment..."  # Immediate feedback during processing
    }
],
Avoid mixing tts_say actions with chat completions as this may result in a conversation flow that feels unnatural. tts_say are best used as filler words when the LLM will take time to generate an completion.

​
Post-Actions
Execute after LLM inference completes. Useful for:

Cleanup operations
State finalization
Ensuring proper sequence of operations

Copy
"post_actions": [
    {
        "type": "end_conversation"  # Ensures TTS completes before ending
    }
]
​
Timing Considerations
Pre-actions: Execute immediately, before any LLM processing begins
LLM Inference: Processes the node’s messages and functions
Post-actions: Execute after LLM processing and TTS completion
For example, when using end_conversation as a post-action, the sequence is:

LLM generates response
TTS speaks the response
End conversation action executes
This ordering ensures proper completion of all operations.

​
Action Types
Flows comes equipped with pre-canned actions and you can also define your own action behavior. See the reference docs for more information.

​
Context Management
Pipecat Flows provides three strategies for managing conversation context during node transitions:

​
Context Strategies
APPEND (default): Adds new messages to the existing context, maintaining the full conversation history
RESET: Clears the context and starts fresh with the new node’s messages
RESET_WITH_SUMMARY: Resets the context but includes an AI-generated summary of the previous conversation
​
Configuration
Context strategies can be configured globally or per-node:


Copy
from pipecat_flows import ContextStrategy, ContextStrategyConfig

# Global strategy configuration
flow_manager = FlowManager(
    task=task,
    llm=llm,
    context_aggregator=context_aggregator,
    context_strategy=ContextStrategyConfig(
        strategy=ContextStrategy.RESET_WITH_SUMMARY,
        summary_prompt="Summarize the key points discussed so far, focusing on decisions made and important information collected."
    )
)

# Per-node strategy configuration
node_config = {
    "task_messages": [...],
    "functions": [...],
    "context_strategy": ContextStrategyConfig(
        strategy=ContextStrategy.RESET_WITH_SUMMARY,
        summary_prompt="Provide a concise summary of the customer's order details and preferences."
    )
}
​
Strategy Selection
Choose your strategy based on your conversation needs:

Use APPEND when full conversation history is important
Use RESET when previous context might confuse the current node’s purpose
Use RESET_WITH_SUMMARY for long conversations where key points need to be preserved
When using RESET_WITH_SUMMARY, if summary generation fails or times out, the system automatically falls back to RESET strategy for resilience.

​
State Management
The state variable in FlowManager is a shared dictionary that persists throughout the conversation. Think of it as a conversation memory that lets you:

Store user information
Track conversation progress
Share data between nodes
Inform decision-making
Here’s a practical example of a pizza ordering flow:


Copy
# Store user choices as they're made
async def select_size(args: FlowArgs) -> FlowResult:
    """Handle pizza size selection."""
    size = args["size"]

    # Initialize order in state if it doesn't exist
    if "order" not in flow_manager.state:
        flow_manager.state["order"] = {}

    # Store the selection
    flow_manager.state["order"]["size"] = size

    return {"status": "success", "size": size}

async def select_toppings(args: FlowArgs) -> FlowResult:
    """Handle topping selection."""
    topping = args["topping"]

    # Get existing order and toppings
    order = flow_manager.state.get("order", {})
    toppings = order.get("toppings", [])

    # Add new topping
    toppings.append(topping)
    order["toppings"] = toppings
    flow_manager.state["order"] = order

    return {"status": "success", "toppings": toppings}

async def finalize_order(args: FlowArgs) -> FlowResult:
    """Process the complete order."""
    order = flow_manager.state.get("order", {})

    # Validate order has required information
    if "size" not in order:
        return {"status": "error", "error": "No size selected"}

    # Calculate price based on stored selections
    size = order["size"]
    toppings = order.get("toppings", [])
    price = calculate_price(size, len(toppings))

    return {
        "status": "success",
        "summary": f"Ordered: {size} pizza with {', '.join(toppings)}",
        "price": price
    }
In this example:

select_size initializes the order and stores the size
select_toppings builds a list of toppings
finalize_order uses the stored information to process the complete order
The state variable makes it easy to:

Build up information across multiple interactions
Access previous choices when needed
Validate the complete order
Calculate final results
This is particularly useful when information needs to be collected across multiple conversation turns or when later decisions depend on earlier choices.

​
LLM Provider Support
Pipecat Flows automatically handles format differences between LLM providers:

​
OpenAI Format

Copy
"functions": [{
    "type": "function",
    "function": {
        "name": "function_name",
        "handler": select_size, # Optional handler
        "description": "description",
        "parameters": {...},
        "transition_to": "target_node" # Optional transition (or transition_callback for dynamic flows)
    }
}]
​
Anthropic Format

Copy
"functions": [{
    "name": "function_name",
    "handler": select_size, # Optional handler
    "description": "description",
    "input_schema": {...},
    "transition_to": "target_node" # Optional transition (or transition_callback for dynamic flows)
}]
​
Google (Gemini) Format

Copy
"functions": [{
    "function_declarations": [{
        "name": "function_name",
        "handler": select_size, # Optional handler
        "description": "description",
        "parameters": {...},
        "transition_to": "target_node" # Optional transition (or transition_callback for dynamic flows)
    }]
}]
You don’t need to handle these differences manually - Pipecat Flows adapts your configuration to the correct format based on your LLM provider.

​
Implementation Approaches
​
Static Flows
Static flows use a configuration-driven approach where the entire conversation structure is defined upfront.

​
Basic Setup

Copy
from pipecat_flows import FlowManager

# Define flow configuration
flow_config = {
    "initial_node": "greeting",
    "nodes": {
        "greeting": {
            "role_messages": [...],
            "task_messages": [...],
            "functions": [...]
        }
    }
}

# Initialize flow manager with static configuration
flow_manager = FlowManager(
    task=task,
    llm=llm,
    context_aggregator=context_aggregator,
    flow_config=flow_config
)

@transport.event_handler("on_first_participant_joined")
async def on_first_participant_joined(transport, participant):
    await transport.capture_participant_transcription(participant["id"])
    await flow_manager.initialize()
​
Example FlowConfig

Copy
flow_config = {
    "initial_node": "start",
    "nodes": {
        "start": {
            "role_messages": [
                {
                    "role": "system",
                    "content": "You are an order-taking assistant. You must ALWAYS use the available functions to progress the conversation. This is a phone conversation and your responses will be converted to audio. Keep the conversation friendly, casual, and polite. Avoid outputting special characters and emojis.",
                }
            ],
            "task_messages": [
                {
                    "role": "system",
                    "content": "You are an order-taking assistant. Ask if they want pizza or sushi."
                }
            ],
            "functions": [
                {
                    "type": "function",
                    "function": {
                        "name": "choose_pizza",
                        "description": "User wants pizza",
                        "parameters": {"type": "object", "properties": {}},
                        "transition_to": "pizza_order"  # Specify transition
                    }
                },
                {
                    "type": "function",
                    "function": {
                        "name": "select_size",
                        "handler": select_size,
                        "description": "Select pizza size",
                        "parameters": {
                            "type": "object",
                            "properties": {
                                "size": {"type": "string", "enum": ["small", "medium", "large"]}
                            }
                        },
                        "transition_to": "toppings"  # Optional transition after processing
                    }
                }
            ]
        }
    }
}
​
Transition Best Practices
Use transition_to to make state changes explicit
Combine handlers with transitions when appropriate
Keep transitions focused on single responsibilities
​
Dynamic Flows
Dynamic flows create and modify conversation paths at runtime based on data or business logic.

​
Example Implementation
Here’s a complete example of a dynamic insurance quote flow:


Copy
from pipecat_flows import FlowManager, FlowArgs, FlowResult

# Define handlers and transitions
async def collect_age(args: FlowArgs) -> AgeResult:
    """Process age collection."""
    age = args["age"]
    return AgeResult(status="success", age=age)

async def handle_age_transition(
    args: Dict,
    result: AgeResult,  # Typed result from handler
    flow_manager: FlowManager
):
    """Transition handler that determines next node based on age."""
    # Use typed result directly
    if result.age < 25:
        await flow_manager.set_node("young_adult", create_young_adult_node())
    else:
        await flow_manager.set_node("standard", create_standard_node())

# Node creation functions
def create_initial_node() -> NodeConfig:
    """Create initial age collection node."""
    return {
        "role_messages": [
            {
                "role": "system",
                "content": "You are an insurance quote assistant."
            }
        ],
        "task_messages": [
            {
                "role": "system",
                "content": "Ask for the customer's age."
            }
        ],
        "functions": [
            {
                "type": "function",
                "function": {
                    "name": "collect_age",
                    "handler": collect_age,
                    "description": "Collect customer age",
                    "parameters": {
                        "type": "object",
                        "properties": {
                            "age": {"type": "integer"}
                        }
                    },
                    "transition_callback": handle_age_transition
                }
            }
        ]
    }

def create_young_adult_node() -> Dict[str, Any]:
    """Create node for young adult quotes."""
    return {
        "task_messages": [
            {
                "role": "system",
                "content": "Explain our special young adult coverage options."
            }
        ],
        "functions": [...]  # Additional quote-specific functions
    }

def create_standard_node() -> Dict[str, Any]:
    """Create node for standard quotes."""
    return {
        "task_messages": [
            {
                "role": "system",
                "content": "Present our standard coverage options."
            }
        ],
        "functions": [...]  # Additional quote-specific functions
    }

# Initialize flow manager
flow_manager = FlowManager(
    task=task,
    llm=llm,
    context_aggregator=context_aggregator,
)

@transport.event_handler("on_first_participant_joined")
async def on_first_participant_joined(transport, participant):
    await transport.capture_participant_transcription(participant["id"])
    await flow_manager.initialize()
    await flow_manager.set_node("initial", create_initial_node())
​
Best Practices
Keep data processing in handlers and flow logic in transition callbacks
Store shared data in flow_manager.state
Create separate functions for node creation
​
Flow Editor
The Pipecat Flow Editor provides a visual interface for creating and managing conversation flows. It offers a node-based interface that makes it easier to design, visualize, and modify your flows.

Food Ordering Flow
​
Visual Design
​
Node Types
Start Node (Green): Entry point of your flow


Copy
"greeting": {
    "role_messages": [...],
    "task_messages": [...],
    "functions": [...]
}
Flow Nodes (Blue): Intermediate states


Copy
"collect_info": {
    "task_messages": [...],
    "functions": [...],
    "pre_actions": [...]
}
End Node (Red): Final state


Copy
"end": {
    "task_messages": [...],
    "functions": [],
    "post_actions": [{"type": "end_conversation"}]
}
Function Nodes:

Edge Functions (Purple): Create transitions

Copy
{
    "name": "next_node",
    "description": "Transition to next state"
}
Node Functions (Orange): Perform operations

Copy
{
    "name": "process_data",
    "handler": process_data_handler,
    "description": "Process user data"
}
​
Naming Conventions
Start Node: Use descriptive names (e.g., “greeting”, “welcome”)
Flow Nodes: Name based on purpose (e.g., “collect_info”, “verify_data”)
End Node: Conventionally named “end”
Functions: Use clear, action-oriented names
​
Function Configuration

Copy
# Edge Function (Transition)
{
    "type": "function",
    "function": {
        "name": "next_state",
        "description": "Clear transition description",
        "parameters": {...}
        "transition_to": "target_node_name" # Transition target
    }
}

# Node Function (Operation)
{
    "type": "function",
    "function": {
        "name": "process_data",
        "handler": process_handler,  # Include handler
        "description": "Clear operation description",
        "parameters": {...}
    }
}
When using the Flow Editor, function handlers can be specified using the __function__: token:


Copy
{
    "type": "function",
    "function": {
        "name": "process_data",
        "handler": "__function__:process_data",  # References function in main script
        "description": "Process user data",
        "parameters": {...}
    }
}
The handler will be looked up in your main script when the flow is executed.

When function handlers are specified in the flow editor, they will be exported with the __function__: token.

​
Using the Editor
​
Creating a New Flow
Start with a descriptively named Start Node
Add Flow Nodes for each conversation state
Connect nodes using Edge Functions
Add Node Functions for operations
Include an End Node
​
Import/Export

Copy
# Export format
{
    "initial_node": "greeting",
    "nodes": {
        "greeting": {
            "role_messages": [...],
            "task_messages": [...],
            "functions": [...],
            "pre_actions": [...]
        },
        "process": {
            "task_messages": [...],
            "functions": [...],
        },
        "end": {
            "task_messages": [...],
            "functions": [],
            "post_actions": [...]
        }
    }
}
​
Tips
Use the visual preview to verify flow logic
Test exported configurations
Document node purposes and transitions
Keep flows modular and maintainable
Try the editor at flows.pipecat.ai


Pipecat Flows provides a framework for building structured conversations in your AI applications. It enables you to create both predefined conversation paths and dynamically generated flows while handling the complexities of state management and LLM interactions.

The framework consists of:

A Python module for building conversation flows with Pipecat
A visual editor for designing and exporting flow configurations
When to Use Pipecat Flows
Static Flows: When your conversation structure is known upfront and follows predefined paths. Perfect for customer service scripts, intake forms, or guided experiences.
Dynamic Flows: When conversation paths need to be determined at runtime based on user input, external data, or business logic. Ideal for personalized experiences or complex decision trees.
Installation
If you're already using Pipecat:

pip install pipecat-ai-flows
If you're starting fresh:

# Basic installation
pip install pipecat-ai-flows

# Install Pipecat with specific LLM provider options:
pip install "pipecat-ai[daily,openai,deepgram,cartesia]"     # For OpenAI
pip install "pipecat-ai[daily,anthropic,deepgram,cartesia]"  # For Anthropic
pip install "pipecat-ai[daily,google,deepgram,cartesia]"     # For Google
Quick Start
Here's a basic example of setting up a static conversation flow:

from pipecat_flows import FlowManager, FlowsFunctionSchema

# Define a function with FlowsFunctionSchema
collect_name_schema = FlowsFunctionSchema(
    name="collect_name",
    description="Record user's name",
    properties={"name": {"type": "string"}},
    required=["name"],
    handler=collect_name_handler,
    transition_to="next_step"
)

# Initialize flow manager with static configuration
flow_config = {
    "initial_node": "greeting",
    "nodes": {
        "greeting": {
            "role_messages": [
                {
                    "role": "system",
                    "content": "You are a helpful assistant. Your responses will be converted to audio."
                }
            ],
            "task_messages": [
                {
                    "role": "system",
                    "content": "Start by greeting the user and asking for their name."
                }
            ],
            "functions": [collect_name_schema]
        },
        # Additional nodes...
    }
}

flow_manager = FlowManager(
    task=task,
    llm=llm,
    context_aggregator=context_aggregator,
    tts=tts,
    flow_config=flow_config,
)

@transport.event_handler("on_first_participant_joined")
async def on_first_participant_joined(transport, participant):
    await transport.capture_participant_transcription(participant["id"])
    await flow_manager.initialize()
For more detailed examples and guides, visit our documentation.

Core Concepts
Flow Configuration
Each conversation flow consists of nodes that define the conversation structure. A node includes:

Messages
Nodes use two types of messages to control the conversation:

Role Messages: Define the bot's personality or role (optional)
"role_messages": [
    {
        "role": "system",
        "content": "You are a friendly pizza ordering assistant. Keep responses casual and upbeat."
    }
]
Task Messages: Define what the bot should do in the current node
"task_messages": [
    {
        "role": "system",
        "content": "Ask the customer which pizza size they'd like: small, medium, or large."
    }
]
Role messages are typically defined in your initial node and inherited by subsequent nodes, while task messages are specific to each node's purpose.

Functions
Functions come in two types:

Node Functions: Execute operations within the current state
Edge Functions: Create transitions between states
Functions can be defined using either the new FlowsFunctionSchema class (recommended) or traditional dictionary format:

# Using FlowsFunctionSchema (recommended)
from pipecat_flows import FlowsFunctionSchema

select_size_schema = FlowsFunctionSchema(
    name="select_size",
    description="Select pizza size",
    properties={"size": {"type": "string", "enum": ["small", "medium", "large"]}},
    required=["size"],
    handler=select_size_handler
)

# Traditional dictionary format
{
    "type": "function",
    "function": {
        "name": "select_size",
        "handler": select_size_handler,
        "description": "Select pizza size",
        "parameters": {
            "type": "object",
            "properties": {
                "size": {"type": "string", "enum": ["small", "medium", "large"]}
            }
        },
    }
}
Functions behave differently based on their type:

Node Functions execute their handler and trigger an immediate LLM completion with the result
Edge Functions execute their handler (if provided) and transition to a new node, with the LLM completion occurring after both the function result and new node's messages are added to context
Functions can:

Have a handler (for data processing)
Have a transition_to or transition callback (for state changes)
Have both (process data and transition)
Have neither (end node functions)
For Static flows, use transition_to:

# Using FlowsFunctionSchema
next_step_schema = FlowsFunctionSchema(
    name="next_step",
    description="Move to next state",
    properties={},
    required=[],
    handler=select_size_handler,  # Optional handler
    transition_to="target_node"   # Specify target node
)

# Using dictionary format
{
    "type": "function",
    "function": {
        "name": "next_step",
        "handler": select_size_handler, # Optional handler
        "description": "Move to next state",
        "parameters": {"type": "object", "properties": {}},
        "transition_to": "target_node"  # Required: Specify target node
    }
}
For Dynamic flows, use transition_callback:

# Using FlowsFunctionSchema
collect_age_schema = FlowsFunctionSchema(
    name="collect_age",
    description="Record user's age",
    properties={"age": {"type": "integer"}},
    required=["age"],
    handler=collect_age,
    transition_callback=handle_age_collection
)

# Using dictionary format
{
    "type": "function",
    "function": {
        "name": "collect_age",
        "handler": collect_age,
        "description": "Record user's age",
        "parameters": {...},
        "transition_callback": handle_age_collection  # Specify transition handler
    }
}
Pipecat Flows automatically handles format differences between LLM providers (OpenAI, Anthropic, and Google Gemini), so you can focus on your conversation logic rather than provider-specific implementations.

Actions
There are two types of actions available:

pre_actions: Run before the LLM inference. For long function calls, you can use a pre_action for the TTS to say something, like "Hold on a moment..."
post_actions: Run after the LLM inference. This is handy for actions like ending or transferring a call.
Actions can be registered in two ways:

Via handler field in action config:
"pre_actions": [
    # Built-in action (no handler needed)
    {
        "type": "tts_say",
        "text": "Processing your order..."
    },
    # Custom action with handler
    {
        "type": "check_status",
        "handler": check_status_handler
    }
]
Via manual registration:
flow_manager.register_action("check_status", check_status_handler)
Built-in actions (tts_say, end_conversation) don't require registration.

Example custom action:

async def check_status_handler(action: dict) -> None:
    """Custom action to check system status."""
    logger.info("Checking system status")
    # Perform status check
Learn more about built-in actions and defining your own action in the docs.

Flow Management
The FlowManager handles both static and dynamic flows through a unified interface:

Static Flows
# Define flow configuration upfront
flow_config = {
    "initial_node": "greeting",
    "nodes": {
        "greeting": {
            "role_messages": [
                {
                    "role": "system",
                    "content": "You are a helpful assistant. Your responses will be converted to audio."
                }
            ],
            "task_messages": [
                {
                    "role": "system",
                    "content": "Start by greeting the user and asking for their name."
                }
            ],
            "functions": [{
                "type": "function",
                "function": {
                    "name": "collect_name",
                    "description": "Record user's name",
                    "parameters": {...},
                    "handler": collect_name_handler,     # Specify handler
                    "transition_to": "next_step"         # Specify transition
                }
            }]
        }
    }
}

# Create and initialize the FlowManager
flow_manager = FlowManager(
    task=task,
    llm=llm,
    context_aggregator=context_aggregator,
    tts=tts,
    flow_config=flow_config,
)
await flow_manager.initialize()
Dynamic Flows
Dynamic flows follow the same pattern as static flows, but use transition_callback instead of transition_to to specify runtime-determined transitions. Here's an example:

# Define handlers
async def update_coverage(args: FlowArgs, flow_manager: FlowManager) -> FlowResult:
    """Update coverage options; node function without a transition."""
    return {"coverage": args["coverage"]}

# Edge function transition handler
async def handle_age_collection(args: Dict, result: FlowResult, flow_manager: FlowManager):
    """Handle age collection transition; edge function which transitions to the next node."""
    # Use typed result directly
    flow_manager.state["age"] = result.age
    await flow_manager.set_node("next", create_next_node())

# Create nodes
def create_initial_node() -> NodeConfig:
    return {
        "role_messages": [
            {
                "role": "system",
                "content": "You are a helpful assistant."
            }
        ],
        "task_messages": [
            {
                "role": "system",
                "content": "Ask the user for their age."
            }
        ],
        "functions": [
            {
                "type": "function",
                "function": {
                    "name": "collect_age",
                    "handler": collect_age,
                    "description": "Record user's age",
                    "parameters": {
                        "type": "object",
                        "properties": {
                            "age": {"type": "integer"}
                        },
                        "required": ["age"]
                    },
                    "transition_callback": handle_age_collection  # Specify transition handler
                }
            }
        ]
    }

# Initialize flow manager
flow_manager = FlowManager(
    task=task,
    llm=llm,
    context_aggregator=context_aggregator,
    tts=tts,
)
await flow_manager.initialize()

@transport.event_handler("on_first_participant_joined")
async def on_first_participant_joined(transport, participant):
    await transport.capture_participant_transcription(participant["id"])
    await flow_manager.initialize()
    await flow_manager.set_node("initial", create_initial_node())
Context Management
The FlowManager provides three strategies for managing conversation context during node transitions:

APPEND (default): Adds new messages to the existing context, maintaining the full conversation history
RESET: Clears the context and starts fresh with the new node's messages, including the previous function call results
RESET_WITH_SUMMARY: Resets the context but includes an AI-generated summary of the previous conversation and the new node's messages
Strategies can be set globally or per-node:

# Global strategy
flow_manager = FlowManager(
    task=task,
    llm=llm,
    context_aggregator=context_aggregator,
    context_strategy=ContextStrategyConfig(
        strategy=ContextStrategy.RESET
    )
)

# Per-node strategy
node_config = {
    "task_messages": [...],
    "functions": [...],
    "context_strategy": ContextStrategyConfig(
        strategy=ContextStrategy.RESET_WITH_SUMMARY,
        summary_prompt="Summarize the key points discussed so far."
    )
}
When using RESET_WITH_SUMMARY, the system automatically falls back to RESET if summary generation fails or times out.

Examples
The repository includes several complete example implementations in the examples/ directory.

Static
In the examples/static directory, you'll find these examples:

food_ordering.py - A restaurant order flow demonstrating node and edge functions
movie_explorer_openai.py - Movie information bot demonstrating real API integration with TMDB
movie_explorer_anthropic.py - The same movie information demo adapted for Anthropic's format
movie_explorer_gemini.py - The same movie explorer demo adapted for Google Gemini's format
patient_intake_openai.py - A medical intake system showing complex state management
patient_intake_anthropic.py - The same medical intake demo adapted for Anthropic's format
patient_intake_gemini.py - The same medical intake demo adapted for Gemini's format
travel_planner.py - A vacation planning assistant with parallel paths
Dynamic
In the examples/dynamic directory, you'll find these examples:

insurance_openai.py - An insurance quote system using OpenAI's format
insurance_anthropic.py - The same insurance system adapted for Anthropic's format
insurance_gemini.py - The insurance system implemented with Google's format
restaurant_reservation.py - A reservation system with availability checking
Each LLM provider (OpenAI, Anthropic, Google) has slightly different function calling formats, but Pipecat Flows handles these differences internally while maintaining a consistent API for developers.

To run these examples:

Setup Virtual Environment (recommended):

python3 -m venv venv
source venv/bin/activate
Installation:

Install the package in development mode:

pip install -e .
Install Pipecat with required options for examples:

pip install "pipecat-ai[daily,openai,deepgram,cartesia,silero,examples]"
If you're running Google or Anthropic examples, you will need to update the installed options. For example:

# Install Google Gemini
pip install "pipecat-ai[daily,google,deepgram,cartesia,silero,examples]"
# Install Anthropic
pip install "pipecat-ai[daily,anthropic,deepgram,cartesia,silero,examples]"
Configuration:

Copy env.example to .env in the examples directory:

cp env.example .env
Add your API keys and configuration:

DEEPGRAM_API_KEY
CARTESIA_API_KEY
OPENAI_API_KEY
ANTHROPIC_API_KEY
GOOGLE_API_KEY
DAILY_API_KEY
Looking for a Daily API key and room URL? Sign up on the Daily Dashboard.

Running:

python examples/static/food_ordering.py -u YOUR_DAILY_ROOM_URL
Tests
The package includes a comprehensive test suite covering the core functionality.

Setup Test Environment
Create Virtual Environment:

python3 -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate
Install Test Dependencies:

pip install -r dev-requirements.txt -r test-requirements.txt
pip install "pipecat-ai[google,openai,anthropic]"
pip install -e .
Running Tests
Run all tests:

pytest tests/
Run specific test file:

pytest tests/test_state.py
Run specific test:

pytest tests/test_state.py -k test_initialization
Run with coverage report:

pytest tests/ --cov=pipecat_flows
Pipecat Flows Editor
A visual editor for creating and managing Pipecat conversation flows.

Food ordering flow example

Features
Visual flow creation and editing
Import/export of flow configurations
Support for node and edge functions
Merge node support for complex flows
Real-time validation
Naming Conventions
While the underlying system is flexible with node naming, the editor follows these conventions for clarity:

Start Node: Named after your initial conversation state (e.g., "greeting", "welcome")
End Node: Conventionally named "end" for clarity, though other names are supported
Flow Nodes: Named to reflect their purpose in the conversation (e.g., "get_time", "confirm_order")
These conventions help maintain readable and maintainable flows while preserving technical flexibility.

Online Editor
The editor is available online at flows.pipecat.ai.

Local Development
Prerequisites
Node.js (v14 or higher)
npm (v6 or higher)
Installation
Clone the repository

git clone git@github.com:pipecat-ai/pipecat-flows.git
Navigate to project directory

cd pipecat-flows/editor
Install dependencies

npm install
Start development server

npm run dev
Open the page in your browser: http://localhost:5173.

Usage
Create a new flow using the toolbar buttons
Add nodes by right-clicking in the canvas
Start nodes can have descriptive names (e.g., "greeting")
End nodes are conventionally named "end"
Connect nodes by dragging from outputs to inputs
Edit node properties in the side panel
Export your flow configuration using the toolbar
Examples
The editor/examples/ directory contains sample flow configurations:

food_ordering.json
movie_explorer.py
patient_intake.json
restaurant_reservation.json
travel_planner.json
To use an example:

Open the editor
Click "Import Flow"
Select an example JSON file
See the examples directory for the complete files and documentation.

Development
Available Scripts
npm start - Start production server
npm run dev - Start development server
npm run build - Build for production
npm run preview - Preview production build locally
npm run preview:prod - Preview production build with base path
npm run lint - Check for linting issues
npm run lint:fix - Fix linting issues
npm run format - Format code with Prettier
npm run format:check - Check code formatting
npm run docs - Generate documentation
npm run docs:serve - Serve documentation locally
Documentation
The Pipecat Flows Editor project uses JSDoc for documentation. To generate and view the documentation:

Generate documentation:

npm run docs
Serve documentation locally:

npm run docs:serve
View in browser by opening: http://localhost:8080

Contributing
We welcome contributions from the community! Whether you're fixing bugs, improving documentation, or adding new features, here's how you can help:

Found a bug? Open an issue
Have a feature idea? Start a discussion
Want to contribute code? Check our CONTRIBUTING.md guide
Documentation improvements? Docs PRs are always welcome
Before submitting a pull request, please check existing issues and PRs to avoid duplicates.

We aim to review all contributions promptly and provide constructive feedback to help get your changes merged.